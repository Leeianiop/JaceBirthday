<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Birthday Game</title>
<link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet" />
<style>
  :root { --card-w: 1200px; --card-h: 600px; }
  * { box-sizing: border-box; }
  body {
    background: #ffffff; 
    margin: 0;
    font-family: 'Pacifico', cursive;
    display: flex;
    align-items: center;
    flex-direction: column;
    min-height: 100vh;
    overflow: hidden; /* keep confetti tidy */
  }
  #birthdayText {
    font-size: 28px;
    cursor: pointer;
    margin-top: 20px;
    z-index: 2;
  }
  #countdown {
    font-size: 22px;
    margin-top: 10px;
    z-index: 2;
  }
  /* Confetti canvas behind everything */
  #confetti {
    position: fixed;
    inset: 0;
    z-index: 0;
    pointer-events: none;
  }
  /* Game canvas on top */
  #gameCanvas {
    background: #ffffff; 
    margin-top: 20px;
    border-radius: 20px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    z-index: 1;
  }
</style>
</head>
<body>

<canvas id="confetti"></canvas>

<div id="birthdayText">Happy 46th Birthday Daddy</div>
<div id="countdown"></div>
<canvas id="gameCanvas" width="1200" height="600"></canvas>

<script>
/* ========= Base setup ========= */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

/* Cycle text (kept as-is) */
const texts = [
  "Happy 46th Birthday Daddy",
  "Happy 46th Birthday Jace",
  "Happy 46th Birthday Lee",
  "Hapi Bday Mah N-"
];
let textIndex = 0;
document.getElementById('birthdayText').addEventListener('click', () => {
  textIndex = (textIndex + 1) % texts.length;
  document.getElementById('birthdayText').innerText = texts[textIndex];
});

/* ========= Countdown to Aug 13 ========= */
function getNextCountdown() {
  const now = new Date();
  let target = new Date(now.getFullYear(), 7, 13); // Aug = 7 (0-based)
  if (now > target) target.setFullYear(now.getFullYear() + 1);
  return target;
}
let targetDate = getNextCountdown();

/* ========= Input ========= */
const keys = {};
document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

/* ========= Images ========= */
const playerRightFrames = [new Image(), new Image()];
playerRightFrames[0].src = 'right 1.png';
playerRightFrames[1].src = 'right 2.png';

const playerLeftFrames = [new Image(), new Image()];
playerLeftFrames[0].src = 'left 1.png';
playerLeftFrames[1].src = 'left 2.png';

const cakeFrames = [new Image(), new Image()];
cakeFrames[0].src = 'cake normal.png';
cakeFrames[1].src = 'cake eaten.png';

const buttonImage = new Image(); buttonImage.src = 'button.png';
const npcImage    = new Image(); npcImage.src    = 'mom.png';   // mom.png is the NPC
const planeImage  = new Image(); planeImage.src  = 'plane.png';

/* ========= Game state ========= */
let player = {
  x: 400, y: 400, width: 200, height: 250,
  dir: 'right', frame: 0, frameTick: 0, jumping: false, vy: 0
};

let cake = { x: 800, y: 430, width: 200, height: 250, frame: 0 };

const playerSpeed = 10;

let planeActive   = false;  // when true, show plane instead of cake
let npcVisible    = false;  // controls NPC visibility
let npcSaidHi     = false;  // whether NPC already greeted
let typedBuffer   = "";     // for detecting user typing "hi"

let buttonX = 20, buttonY = 100, buttonW = 80, buttonH = 80;

/* ========= Helpers ========= */
function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }

function drawRoundedRect(x, y, w, h, r, fillStyle) {
  ctx.fillStyle = fillStyle;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
  ctx.fill();
}

function drawPlayer() {
  const pf = player.dir === 'right' ? playerRightFrames[player.frame] : playerLeftFrames[player.frame];
  if (pf.complete) {
    ctx.drawImage(pf, player.x, player.y, player.width, player.height);
  } else {
    ctx.fillStyle = 'red';
    ctx.fillRect(player.x, player.y, player.width, player.height);
  }
}

function drawCake() {
  const cf = cakeFrames[cake.frame];
  if (cf.complete) {
    ctx.drawImage(cf, cake.x, cake.y, cake.width, cake.height);
  } else {
    ctx.fillStyle = 'pink';
    ctx.fillRect(cake.x, cake.y, cake.width, cake.height);
  }
  ctx.fillStyle = 'black';
  ctx.font = '24px Pacifico';
  ctx.fillText('(Press A to eat)', cake.x + 20, cake.y + 15);
}

function drawPlane() {
  if (planeImage.complete) ctx.drawImage(planeImage, 650, 340, 350, 180);
  else { ctx.fillStyle = 'gray'; ctx.fillRect(650, 340, 350, 180); }
}

/* NPC bubble that says "Hi" */
function drawNPC() {
  if (!npcVisible) return;
  const nx = 320, ny = 340, nw = 160, nh = 220; // npc position/size
  if (npcImage.complete) ctx.drawImage(npcImage, nx, ny, nw, nh);
  else { ctx.fillStyle = 'orange'; ctx.fillRect(nx, ny, nw, nh); }
  // speech bubble
  const bx = nx + nw + 20, by = ny + 40, bw = 140, bh = 60, r = 12;
  ctx.fillStyle = 'white';
  drawRoundedRect(bx, by, bw, bh, r, 'white');
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 2;
  ctx.strokeRect(bx, by, bw, bh);
  ctx.fillStyle = 'black';
  ctx.font = '26px Pacifico';
  ctx.fillText('Hi', bx + 15, by + 38);
}

/* Button with rounded frame, image slightly overdrawn */
function drawButton() {
  // Frame clip
  ctx.save();
  ctx.beginPath();
  const r = 15;
  ctx.moveTo(buttonX + r, buttonY);
  ctx.lineTo(buttonX + buttonW - r, buttonY);
  ctx.quadraticCurveTo(buttonX + buttonW, buttonY, buttonX + buttonW, buttonY + r);
  ctx.lineTo(buttonX + buttonW, buttonY + buttonH - r);
  ctx.quadraticCurveTo(buttonX + buttonW, buttonY + buttonH, buttonX + buttonW - r, buttonY + buttonH);
  ctx.lineTo(buttonX + r, buttonY + buttonH);
  ctx.quadraticCurveTo(buttonX, buttonY + buttonH, buttonX, buttonY + buttonH - r);
  ctx.lineTo(buttonX, buttonY + r);
  ctx.quadraticCurveTo(buttonX, buttonY, buttonX + r, buttonY);
  ctx.closePath();
  ctx.clip();

  const overdraw = 10;
  if (buttonImage.complete) {
    ctx.drawImage(buttonImage, buttonX - overdraw, buttonY - overdraw, buttonW + overdraw*2, buttonH + overdraw*2);
  } else {
    ctx.fillStyle = 'lightblue';
    ctx.fillRect(buttonX, buttonY, buttonW, buttonH);
  }
  ctx.restore();

  // Outline
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(buttonX + r, buttonY);
  ctx.lineTo(buttonX + buttonW - r, buttonY);
  ctx.quadraticCurveTo(buttonX + buttonW, buttonY, buttonX + buttonW, buttonY + r);
  ctx.lineTo(buttonX + buttonW, buttonY + buttonH - r);
  ctx.quadraticCurveTo(buttonX + buttonW, buttonY + buttonH, buttonX + buttonW - r, buttonY + buttonH);
  ctx.lineTo(buttonX + r, buttonY + buttonH);
  ctx.quadraticCurveTo(buttonX, buttonY + buttonH, buttonX, buttonY + buttonH - r);
  ctx.lineTo(buttonX, buttonY + r);
  ctx.quadraticCurveTo(buttonX, buttonY, buttonX + r, buttonY);
  ctx.closePath();
  ctx.stroke();
}

/* ========= Mouse: clicking the button ========= */
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  if (mx > buttonX && mx < buttonX + buttonW && my > buttonY && my < buttonY + buttonH) {
    // Cake instantly becomes plane, NPC appears and says Hi first
    planeActive = true;
    npcVisible  = true;
    npcSaidHi   = true; // already greeted
  }
});

/* ========= Keyboard actions ========= */
document.addEventListener('keydown', (e) => {
  const k = e.key.toLowerCase();

  // Eat cake: show eaten frame for 0.5s, then back (only if cake is visible)
  if (!planeActive && k === 'a') {
    cake.frame = 1;
    setTimeout(() => { cake.frame = 0; }, 500);
  }

  // Movement & jump
  if (k === 'arrowup' && !player.jumping) {
    player.jumping = true;
    player.vy = -15;
  }
});

/* Typing "hi" back to NPC */
document.addEventListener('keypress', (e) => {
  if (!npcVisible) return;
  const ch = e.key;
  if (ch.length === 1) {
    typedBuffer += ch;
    if (typedBuffer.length > 10) typedBuffer = typedBuffer.slice(-10);
    if (typedBuffer.toLowerCase().endsWith('hi')) {
      // Player said hi back â†’ NPC disappears, plane stays
      npcVisible = false;
      typedBuffer = '';
    }
  }
});

/* ========= Game loop ========= */
function gameLoop() {
  // Clear
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Countdown text (DOM)
  const now = new Date();
  if (now >= targetDate) targetDate = getNextCountdown();
  const diff = targetDate - now;
  const days = Math.floor(diff / (1000*60*60*24));
  const hours = Math.floor((diff / (1000*60*60)) % 24);
  const minutes = Math.floor((diff / (1000*60)) % 60);
  const seconds = Math.floor((diff / 1000) % 60);
  document.getElementById('countdown').innerText = `${days}d ${hours}h ${minutes}m ${seconds}s`;

  // Rounded countdown bar
  const barX = 200, barY = 50, barW = 800, barH = 30, radius = 15;
  drawRoundedRect(barX, barY, barW, barH, radius, 'black');
  drawRoundedRect(barX + 2, barY + 2, barW - 4, barH - 4, radius - 2, 'white');

  // Draw scene
  if (planeActive) {
    drawPlane();
  } else {
    drawCake();
  }

  // Player movement & animation (only affects player)
  if (keys['arrowleft']) {
    player.x -= playerSpeed;
    player.dir = 'left';
    player.frameTick++;
  } else if (keys['arrowright']) {
    player.x += playerSpeed;
    player.dir = 'right';
    player.frameTick++;
  } else {
    player.frame = 0;
    player.frameTick = 0;
  }
  if (player.frameTick > 10) {
    player.frame = (player.frame + 1) % 2;
    player.frameTick = 0;
  }

  // Jump physics
  if (player.jumping) {
    player.y += player.vy;
    player.vy += 1;
    if (player.y >= 400) {
      player.y = 400;
      player.jumping = false;
      player.vy = 0;
    }
  }

  // Clamp player to canvas
  player.x = clamp(player.x, 0, canvas.width - player.width);
  player.y = clamp(player.y, 0, canvas.height - player.height);

  // Draw player (always)
  drawPlayer();

  // NPC (only when visible)
  drawNPC();

  // Button (always visible)
  drawButton();

  requestAnimationFrame(gameLoop);
}
gameLoop();

/* ========= Confetti (outer frame) ========= */
const confetti = document.getElementById('confetti');
const cctx = confetti.getContext('2d');
function sizeConfetti() {
  confetti.width = window.innerWidth;
  confetti.height = window.innerHeight;
}
sizeConfetti();
window.addEventListener('resize', sizeConfetti);

const pieces = Array.from({ length: 160 }).map(() => ({
  x: Math.random() * confetti.width,
  y: Math.random() * confetti.height,
  s: Math.random() * 6 + 4,
  v: Math.random() * 1.5 + 0.5,
  c: `hsl(${Math.random() * 360}, 100%, 50%)`,
  r: Math.random() * Math.PI
}));

function drawConfetti() {
  cctx.clearRect(0, 0, confetti.width, confetti.height);
  pieces.forEach(p => {
    cctx.save();
    cctx.translate(p.x, p.y);
    cctx.rotate(p.r);
    cctx.fillStyle = p.c;
    cctx.fillRect(-p.s / 2, -p.s / 2, p.s, p.s);
    cctx.restore();
    p.y += p.v * 2;
    p.r += 0.02;
    if (p.y > confetti.height + 20) {
      p.y = -20;
      p.x = Math.random() * confetti.width;
    }
  });
  requestAnimationFrame(drawConfetti);
}
drawConfetti();
</script>
</body>
</html>



