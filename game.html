<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Birthday Countdown Game</title>
  <style>
    body {
      background: #ffffff;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: pacifico;
      position: relative;
      overflow: hidden;
      margin: 0;
    }
    h1, h2, h3 {
      position: relative;
      z-index: 3; /* always above canvases */
      margin: 5px;
      color: #000000;
      text-shadow: 2px 2px 5px #aaa;
    }
    h1 { cursor: pointer; user-select: none; margin-top: 10px; }
    canvas {
      border-radius: 20px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    #confettiCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1; /* âœ… behind game */
    }
    #gameCanvas {
      position: relative;
      z-index: 2; /* âœ… above confetti, below text */
    }
  </style>
</head>
<body>
  <h1 id="birthdayText">Happy Birthday Daddy</h1>
  <h2 id="countdown"></h2>
  <h3>until next Birthday ðŸŽ‰ðŸŽ‰</h3>

  <canvas id="confettiCanvas"></canvas>
  <canvas id="gameCanvas" width="1200" height="600"></canvas>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const confettiCanvas = document.getElementById('confettiCanvas');
    const confettiCtx = confettiCanvas.getContext('2d');
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;

    /* ====== Text cycling ====== */
    const texts = ["Happy 46th Birthday Daddy", "Happy 46th Birthday Jace", "Happy 46th Birthday Lee"];
    let textIndex = 0;
    document.getElementById('birthdayText').addEventListener('click', () => {
      textIndex = (textIndex + 1) % texts.length;
      document.getElementById('birthdayText').innerText = texts[textIndex];
    });

    /* ====== Countdown setup ====== */
    function getNextCountdown() {
      const now = new Date();
      let target = new Date(now.getFullYear(), 7, 13); // August 13
      if (now > target) target.setFullYear(now.getFullYear() + 1);
      return target;
    }
    let targetDate = getNextCountdown();

    /* ====== Key handling ====== */
    const keys = {};
    document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
    document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

    /* ====== Sprites ====== */
    const playerRightFrames = [new Image(), new Image()];
    playerRightFrames[0].src = 'right 1.png';
    playerRightFrames[1].src = 'right 2.png';
    const playerLeftFrames = [new Image(), new Image()];
    playerLeftFrames[0].src = 'left 1.png';
    playerLeftFrames[1].src = 'left 2.png';
    const cakeFrames = [new Image(), new Image()];
    cakeFrames[0].src = 'cake normal.png';
    cakeFrames[1].src = 'cake eaten.png';
    let imagesToLoad = 6;
    [playerRightFrames[0], playerRightFrames[1], playerLeftFrames[0], playerLeftFrames[1], cakeFrames[0], cakeFrames[1]]
      .forEach(img => { img.onload = () => { imagesToLoad--; } });
// A â†’ B â†’ C sprite
const abcFrames = [new Image(), new Image(), new Image()];
abcFrames[0].src = "a.png"; 
abcFrames[1].src = "b.png"; 
abcFrames[2].src = "c.png"; 

let abcSprite = {
  x: 100,  // position on canvas
  y: 300,
  width: 200,
  height: 200,
  frame: 0
};


    /* ====== Game objects ====== */
    let player = { x: 400, y: 400, width: 200, height: 250, dir: "right", frame: 0, frameTick: 0, jumping: false, vy: 0 };
    let cake = { x: 800, y: 430, width: 200, height: 250, frame: 0 };
    const playerSpeed = 10;

  /* ====== Cake eating ====== */
let eatCount = 0;
let showImage = false;
let specialImg = new Image();
specialImg.src = "obese.png";

document.addEventListener("keydown", (e) => {
  if (e.key.toLowerCase() === "a" && !showImage) {
    eatCount++;
    if (eatCount >= 15) showImage = true;
  }
});

/* ====== ABC sprite click detection ====== */
canvas.addEventListener("click", (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  if (
    mx >= abcSprite.x && mx <= abcSprite.x + abcSprite.width &&
    my >= abcSprite.y && my <= abcSprite.y + abcSprite.height
  ) {
    abcSprite.frame = (abcSprite.frame + 1) % 3; // cycle Aâ†’Bâ†’Câ†’A
  }
});

    /* ====== Rounded rectangle helper ====== */
    function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    /* ====== Confetti ====== */
    let confetti = [];
    function spawnConfetti(x, y) {
      for (let i = 0; i < 30; i++) {
        confetti.push({
          x: x, y: y,
          dx: (Math.random() - 0.5) * 6,
          dy: (Math.random() - 0.5) * 6,
          size: Math.random() * 6 + 4,
          color: `hsl(${Math.random() * 360}, 100%, 50%)`,
          life: 100
        });
      }
    }
    function updateConfetti() {
      confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
      confetti = confetti.filter(c => c.life > 0);
      confetti.forEach(c => {
        c.x += c.dx;
        c.y += c.dy;
        c.dy += 0.1; // gravity
        c.life--;
        confettiCtx.fillStyle = c.color;
        confettiCtx.fillRect(c.x, c.y, c.size, c.size);
      });
    }
    document.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      spawnConfetti(e.clientX - rect.left, e.clientY - rect.top);
    });

    /* ====== Game loop ====== */
    function gameLoop() {
      if (imagesToLoad > 0) {
        requestAnimationFrame(gameLoop);
        return;
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Countdown
      const now = new Date();
      if (now >= targetDate) targetDate = getNextCountdown();
      let diff = targetDate - now;
      const days = Math.floor(diff / (1000 * 60 * 60 * 24));
      const hours = Math.floor((diff / (1000 * 60 * 60)) % 24);
      const minutes = Math.floor((diff / (1000 * 60)) % 60);
      const seconds = Math.floor((diff / 1000) % 60);
      document.getElementById('countdown').innerText = `${days}d ${hours}h ${minutes}m ${seconds}s`;

      // Progress Bar
      const barX = 100, barY = 100, barWidth = 1000, barHeight = 40, radius = 20;
      ctx.fillStyle = "#ddd";
      roundRect(ctx, barX, barY, barWidth, barHeight, radius, true, false);
      let totalSeconds = (targetDate - now) / 1000;
      let yearSeconds = (getNextCountdown().getTime() - new Date(now.getFullYear(), 7, 13).getTime()) / 1000;
      let progress = 1 - totalSeconds / yearSeconds;
      ctx.fillStyle = "#76c7c0";
      roundRect(ctx, barX, barY, barWidth * Math.max(0, progress), barHeight, radius, true, false);

      if (!showImage) {
        // Draw ABC sprite
ctx.drawImage(abcFrames[abcSprite.frame], abcSprite.x, abcSprite.y, abcSprite.width, abcSprite.height);

        // Player movement
        if (keys['arrowleft']) {
          player.x -= playerSpeed;
          player.dir = "left";
          player.frameTick++;
          if (player.frameTick > 10) {
            player.frame = (player.frame + 1) % 2;
            player.frameTick = 0;
          }
        } else if (keys['arrowright']) {
          player.x += playerSpeed;
          player.dir = "right";
          player.frameTick++;
          if (player.frameTick > 10) {
            player.frame = (player.frame + 1) % 2;
            player.frameTick = 0;
          }
        } else {
          player.frame = 0;
          player.frameTick = 0;
        }

        // Jump
        if (keys['arrowup'] && !player.jumping) {
          player.jumping = true;
          player.vy = -15;
        }
        if (player.jumping) {
          player.y += player.vy;
          player.vy += 1;
          if (player.y >= 400) {
            player.y = 400;
            player.jumping = false;
            player.vy = 0;
          }
        }

        // Cake
        cake.frame = keys['a'] ? 1 : 0;
        ctx.drawImage(cakeFrames[cake.frame], cake.x, cake.y, cake.width, cake.height);
        ctx.fillStyle = "black";
        ctx.font = "24px Arial";
        let lines = ["Infinitely generative cake", "(Press A to eat)"];
        for (let i = 0; i < lines.length; i++) {
          ctx.fillText(lines[i], cake.x + 20, cake.y - 20 + i * 35);
        }

        // Player
        let pf = player.dir === "right" ? playerRightFrames[player.frame] : playerLeftFrames[player.frame];
        ctx.drawImage(pf, player.x, player.y, player.width, player.height);
      } else {
        // Special image covers whole canvas
let imgWidth = 1000;
let imgHeight = 1000;
let imgX = (canvas.width - imgWidth) / 2;  // center horizontally
let imgY = ((canvas.height - imgHeight) / 2) + 70; // center vertically

ctx.drawImage(specialImg, imgX, imgY, imgWidth, imgHeight);

      }

      // Confetti
      updateConfetti();

      requestAnimationFrame(gameLoop);
    }
    gameLoop();
  </script>
</body>
</html>










